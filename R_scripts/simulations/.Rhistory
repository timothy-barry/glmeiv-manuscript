n = n,
B = 500,
m_intercept = log(0.01),
g_intercept = log(0.005),
m_perturbation = m_perturbation,
covariate_matrix = data.frame(lib_size = rpois(n = n, lambda = 10000),
batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = c(0.0025, 0.1),
g_covariate_coefs = c(-0.005, 0.2),
alpha = 0.95,
n_em_rep = 25,
save_membership_probs_mult = 1000L,
pi = 0.05,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.1),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_3 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "thresholding"))
check <- check_simulatr_specifier_object(simulatr_spec = sim_spec_3, B_in = 2)
n <- 20000
m_perturbation <- log(0.5)
thetas <- c(1, 3, 5, 10, 20, 50, 100)
m_fams <- lapply(thetas, function(theta) MASS::negative.binomial(theta) |> augment_family_object())
param_grid <- expand.grid(m_fam = m_fams,
run_unknown_theta_precomputation = c(TRUE, FALSE))
param_grid$ground_truth <- m_perturbation
param_grid$grid_id <- seq(1L, nrow(param_grid))
fixed_params <- list(
g_fam = poisson(),
seed = 4,
n = n,
B = 500,
g_perturbation = log(2),
m_intercept = log(0.01),
g_intercept = log(0.005),
m_perturbation = m_perturbation,
covariate_matrix = data.frame(lib_size = rpois(n = n, lambda = 10000),
batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = c(0.0025, 0.1),
g_covariate_coefs = c(-0.005, 0.2),
alpha = 0.95,
n_em_rep = 25,
save_membership_probs_mult = 1000L,
pi = 0.05,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.1),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_3 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "thresholding"))
check <- check_simulatr_specifier_object(simulatr_spec = sim_spec_3, B_in = 2)
n <- 20000
m_perturbation <- log(0.5)
thetas <- c(1, 3, 5, 10, 20, 50, 100)
m_fams <- lapply(thetas, function(theta) MASS::negative.binomial(theta) |> augment_family_object())
param_grid <- expand.grid(m_fam = m_fams,
run_unknown_theta_precomputation = c(TRUE, FALSE))
param_grid$ground_truth <- m_perturbation
param_grid$grid_id <- seq(1L, nrow(param_grid))
fixed_params <- list(
g_fam = poisson(),
seed = 4,
n = n,
B = 500,
g_perturbation = log(2),
m_intercept = log(0.01),
g_intercept = log(0.005),
m_perturbation = m_perturbation,
covariate_matrix = data.frame(lib_size = rpois(n = n, lambda = 10000),
batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = c(0.0025, 0.1),
g_covariate_coefs = c(-0.005, 0.2),
alpha = 0.95,
n_em_rep = 25,
save_membership_probs_mult = 1000L,
pi = 0.05,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.1),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
n <- 20000
m_perturbation <- log(0.5)
thetas <- c(1, 3, 5, 10, 20, 50, 100)
m_fams <- lapply(thetas, function(theta) MASS::negative.binomial(theta) |> augment_family_object())
param_grid <- expand.grid(m_fam = m_fams,
run_unknown_theta_precomputation = c(TRUE, FALSE))
param_grid$ground_truth <- m_perturbation
param_grid$grid_id <- seq(1L, nrow(param_grid))
fixed_params <- list(
g_fam = poisson() |> augment_family_object(),
seed = 4,
n = n,
B = 500,
g_perturbation = log(2),
m_intercept = log(0.01),
g_intercept = log(0.005),
m_perturbation = m_perturbation,
covariate_matrix = data.frame(lib_size = rpois(n = n, lambda = 10000),
batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = c(0.0025, 0.1),
g_covariate_coefs = c(-0.005, 0.2),
alpha = 0.95,
n_em_rep = 25,
save_membership_probs_mult = 1000L,
pi = 0.05,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.1),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_3 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "thresholding"))
check <- check_simulatr_specifier_object(simulatr_spec = sim_spec_3, B_in = 2)
check
check |> names()
check |> str()
check |> length()
check[[1]]
check[[1]] |> names()
check[[1]]
library(magrittr)
library(glmeiv)
library(simulatr)
args <- commandArgs(trailingOnly = TRUE)
overwrite <- if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
3 * 60 + 53
(3 * 60 + 53)/5
46.6 * 500
(46.6 * 500)/60^2
install.packages("mixtools")
install.packages("flexmix")
21
1 * 500
500 / 60^2
500 / 60
g_perturbation_grid <- log(seq(3)) # g_perturbation_grid <- log(seq(1, 4, 0.5))
g_perturbation_grid
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 15000 # n <- 150000
g_perturbation_grid <- log(seq(3)) # g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson() |> glmeiv::augment_family_object())
})
param_grid$m_fam <- param_grid$g_fam <- fam_obj
param_grid$run_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
fixed_params <- list(
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
# methods = c("glmeiv_fast", "thresholding"))
sim_spec_1@parameter_grid
####################################################################
# Experiment 1 (main text simulation)
# Vary g_pert, fix all other parameters
# Vary distribution: Poisson, NB (known theta), NB (estimated theta)
# One covariate: batch (bernoulli variable)
####################################################################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 15000 # n <- 150000
g_perturbation_grid <- log(3) # g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
param_grid
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson() |> glmeiv::augment_family_object())
})
param_grid$m_fam <- param_grid$g_fam <- fam_obj
param_grid$run_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
param_grid
fixed_params <- list(
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
sim_spec_1
sim_spec_1@parameter_grid
# methods = c("glmeiv_fast", "thresholding"))
# check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1,
#                                                    B_in = 2, parallel = TRUE)
save_obj(obj = sim_spec_1, file_path = paste0(sim_dir, "/sim_spec_1.rds"), overwrite = overwrite)
args <- "/Users/timbarry/research_offsite/projects/glmeiv/public/simulations/spec_objects/sim_spec_1.rds glmeiv_slow 3 5 0 3 4" |> .split_args()
args
simulatr_spec <- readRDS(args[1])
method <- args[2]
row_idx <- as.integer(args[3])
B_check <- as.integer(args[4])
B_in <- as.integer(args[5])
max_gb <- as.numeric(args[6])
max_hours <- as.numeric(args[7])
# extract data generator and its ordered arguments
data_generator <- simulatr_spec@generate_data_function
# extract the method object and its ordered arguments
method_object <- simulatr_spec@run_method_functions[[method]]
ordered_args_method <- c(list(NA), get_ordered_args(method_object, simulatr_spec, row_idx))
method_object
# extract the seed (OK if duplicated across processes)
seed <- simulatr_spec@fixed_parameters$seed
set.seed(seed)
# benchmark data generation
invisible(gc())
data_generator@loop
data_bytes <- pryr::mem_change(
data_seconds <- system.time(
if (data_generator@loop) {
ordered_args_data_gen <- get_ordered_args(data_generator, simulatr_spec, row_idx)
data_list <- lapply(
1:B_check,
function(b) {
do.call(data_generator@f, ordered_args_data_gen)
}
)
} else {
simulatr_spec@fixed_parameters$B <- B_check
ordered_args_data_gen <- get_ordered_args(data_generator, simulatr_spec, row_idx)
data_list <- do.call(data_generator@f, ordered_args_data_gen)
}
)[["elapsed"]]
) |> as.numeric()
data_bytes_per_rep <- data_bytes / B_check
data_seconds_per_rep <- data_seconds / B_check
data_seconds_per_rep
method_object@loop
# benchmark method application
method_bytes <- pryr::mem_change(
if (method_object@loop) {
result_list <- vector(mode = "list", length = B_check)
method_seconds <- vector(mode = "numeric", length = B_check)
for (b in 1:B_check) {
curr_df <- data_list[[b]]
ordered_args_method[[1]] <- curr_df
method_seconds[b] <- system.time(
out <- R.utils::withSeed(do.call(method_object@f, ordered_args_method),
seed = seed)
)[["elapsed"]]
out$run_id <- b
result_list[[b]] <- out
}
result_df <- do.call(rbind, result_list)
method_seconds_per_rep <- max(method_seconds)
} else {
stop("Method loop not yet implemented.")
ordered_args_method[[1]] <- data_list
method_seconds_total <- system.time(
result_df <- do.call(method_object@f, ordered_args_method)
)[["elapsed"]]
method_seconds_per_rep <- method_seconds_total / B_check
}
) |> as.numeric()
method_bytes_per_rep <- method_bytes / B_check
# compute the number of processors needed
B <- if (B_in != 0) B_in else simulatr_spec@fixed_parameters$B
B
B_in
simulatr_spec@fixed_parameters$B
simulatr_spec <- readRDS(args[1])
method <- args[2]
row_idx <- as.integer(args[3])
B_check <- as.integer(args[4])
B_in <- as.integer(args[5])
max_gb <- as.numeric(args[6])
max_hours <- as.numeric(args[7])
simulatr_spec@fixed_parameters$B
simulatr_spec_modb <- simulatr_spec
B_check
simulatr_spec_modb <- simulatr_spec
simulatr_spec_modb@fixed_parameters$B <- B_check
simulatr_spec_modb
simulatr_spec_modb@fixed_parameters$B <- B_check
ordered_args_data_gen <- get_ordered_args(data_generator, simulatr_spec, row_idx)
ordered_args_data_gen |> nameS()
ordered_args_data_gen |> names()
ordered_args_data_gen <- get_ordered_args(data_generator, simulatr_spec, row_idx)
data_generator@f
data_generator@f
ordered_args_data_gen[[9]]
simulatr_spec_modb <- simulatr_spec
simulatr_spec_modb@fixed_parameters$B <- B_check
ordered_args_data_gen <- get_ordered_args(data_generator, simulatr_spec_modb, row_idx)
ordered_args_data_gen[[9]]
data_list <- do.call(data_generator@f, ordered_args_data_gen)
data_bytes <- pryr::mem_change(
data_seconds <- system.time(
if (data_generator@loop) {
ordered_args_data_gen <- get_ordered_args(data_generator, simulatr_spec, row_idx)
data_list <- lapply(
1:B_check,
function(b) {
do.call(data_generator@f, ordered_args_data_gen)
}
)
} else {
simulatr_spec_modb <- simulatr_spec
simulatr_spec_modb@fixed_parameters$B <- B_check
ordered_args_data_gen <- get_ordered_args(data_generator, simulatr_spec_modb, row_idx)
data_list <- do.call(data_generator@f, ordered_args_data_gen)
}
)[["elapsed"]]
) |> as.numeric()
data_bytes_per_rep <- data_bytes / B_check
data_seconds_per_rep <- data_seconds / B_check
B_check
method_object@loop
method_object@loop
result_list <- vector(mode = "list", length = B_check)
method_seconds <- vector(mode = "numeric", length = B_check)
length(data_list)
curr_df <- data_list[[b]]
ordered_args_method[[1]] <- curr_df
b
b
method_object@loop
curr_df <- data_list[[b]]
ordered_args_method[[1]] <- curr_df
method_seconds[b] <- system.time(
out <- do.call(method_object@f, ordered_args_method)
)[["elapsed"]]
result_list <- vector(mode = "list", length = B_check)
method_seconds <- vector(mode = "numeric", length = B_check)
for (b in 1:B_check) {
curr_df <- data_list[[b]]
ordered_args_method[[1]] <- curr_df
method_seconds[b] <- system.time(
out <- do.call(method_object@f, ordered_args_method)
)[["elapsed"]]
out$run_id <- b
result_list[[b]] <- out
}
out
result_list
method_seconds
result_df <- do.call(rbind, result_list)
method_seconds_per_rep <- max(method_seconds)
method_seconds_per_rep
method_bytes
method_bytes_per_rep <- method_bytes / B_check
method_bytes_per_rep
B_in != 0
# compute the number of processors needed
B <- if (B_in != 0) B_in else simulatr_spec@fixed_parameters$B
B
gb_per_rep <- (data_bytes_per_rep + method_bytes_per_rep) / 1e9
gb_per_rep
hrs_per_rep <- (data_seconds_per_rep + method_seconds_per_rep) / (60 * 60)
hrs_per_rep
B
n_processors <- max(ceiling(B * hrs_per_rep / (1.0 * max_hours)),
ceiling(B * gb_per_rep / (1.0 * max_gb)))
n_processors
max(ceiling(B * hrs_per_rep / (1.25 * max_hours)),
ceiling(B * gb_per_rep / (1.25 * max_gb)))
# write benchmarking information
benchmarking_info <- data.frame(method = method,
grid_id = row_idx,
gb_per_rep = method_bytes_per_rep / 1e9,
hrs_per_rep = method_seconds_per_rep / (60*60),
n_processors = n_processors)
benchmarking_info
# write processors information
proc_id_info <- data.frame(method = method,
grid_id = row_idx,
proc_id = 1:n_processors,
n_processors = n_processors)
proc_id_info
proc_id_info
"/Users/timbarry/research_offsite/projects/glmeiv/public/simulations/spec_objects/sim_spec_1.rds glmeiv_slow 1 1 2 0" |> .split_args() -> args
simulatr_spec <- readRDS(args[1])
method <- args[2]
row_idx <- as.integer(args[3])
proc_id <- as.integer(args[4])
n_processors <- as.integer(args[5])
B_in <- as.integer(args[6])
# extract data generator and its ordered arguments
data_generator <- simulatr_spec@generate_data_function
# extract the method object and its ordered arguments
method_object <- simulatr_spec@run_method_functions[[method]]
ordered_args_method <- c(list(NA), get_ordered_args(method_object, simulatr_spec, row_idx))
# set the parallel seed
seed <- simulatr_spec@fixed_parameters$seed
.lec.SetPackageSeed(4) |> invisible()
#!/usr/bin/env Rscript
library(simulatr)
library(rlecuyer)
simulatr_spec <- readRDS(args[1])
method <- args[2]
row_idx <- as.integer(args[3])
proc_id <- as.integer(args[4])
n_processors <- as.integer(args[5])
B_in <- as.integer(args[6])
n_processors
proc_id
# extract data generator and its ordered arguments
data_generator <- simulatr_spec@generate_data_function
# extract the method object and its ordered arguments
method_object <- simulatr_spec@run_method_functions[[method]]
ordered_args_method <- c(list(NA), get_ordered_args(method_object, simulatr_spec, row_idx))
# set the parallel seed
seed <- simulatr_spec@fixed_parameters$seed
.lec.SetPackageSeed(4) |> invisible()
snames <- as.character(seq(1, n_processors))
.lec.CreateStream(snames) |> invisible()
.lec.CurrentStream(snames[proc_id]) |> invisible()
# determine the number of datasets to generate
B <- if (B_in != 0) B_in else simulatr_spec@fixed_parameters$B
B
n_datasets_to_generate <- ceiling(B/n_processors)
n_datasets_to_generate
data_generator@loop
