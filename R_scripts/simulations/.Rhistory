g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
library(magrittr)
library(glmeiv)
library(simulatr)
print("Running create sim_spec objects")
args <- commandArgs(trailingOnly = TRUE)
overwrite <- TRUE # if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
####################################################################
# Experiment 1 (main text simulation)
# Vary g_pert, fix all other parameters
# Vary distribution: Poisson, NB (known theta), NB (estimated theta)
# One covariate: batch (bernoulli variable)
####################################################################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 50000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson() |> glmeiv::augment_family_object())
})
param_grid$m_fam <- fam_obj
param_grid$run_mrna_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
fixed_params <- list(
g_fam = poisson() |> augment_family_object(),
run_grna_unknown_theta_precomputation = FALSE,
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "thresholding", "unimodal_mixture"))
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1, B_in = 2, parallel = TRUE)
check$metrics
check$metrics |> print(n = 100)
check$metrics |> print(n =400)
check$results
check$results |> dplyr::filter(method == "unimodal_mixture")
x <- check$results |> dplyr::filter(method == "unimodal_mixture")
x$output[[1]]
class(x)
dim(X)
dim(x)
x <- check$results |> dplyr::filter(method == "unimodal_mixture")
class(x)
x
x$output
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1, B_in = 2, parallel = TRUE, return_data = TRUE)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = "thresholding")
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1, B_in = 2, parallel = TRUE, return_data = TRUE)
check$metrics
check$data |> length()
check$data[[21]] |> length()
dat <- check$data[[21]][[1]]
head(dat)
tail(dat)
head(dat)
dat$p |> sum()
g_intercept
g_fam = poisson() |> augment_family_object()
run_grna_unknown_theta_precomputation = FALSE
seed = 4
n = n
B = 500
m_intercept = log(0.01)
m_perturbation = log(0.25)
g_intercept = log(0.005)
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5))
m_covariate_coefs = log(0.9)
g_covariate_coefs = log(1.1)
alpha = 0.95
n_em_rep = 15
save_membership_probs_mult = 1000L
pi = 0.02
m_offset = log(rpois(n = n, lambda = 10000))
g_offset = log(rpois(n = n, lambda = 5000))
pi_guess_range = c(1e-5, 0.03)
m_perturbation_guess_range = log(c(0.1, 1.5))
g_perturbation_guess_range = log(c(0.5, 10))
m_intercept_guess_range = log(c(1e-4, 1e-1))
g_intercept_guess_range = log(c(1e-4, 1e-1))
m_covariate_coefs_guess_range = log(c(0.25, 2))
g_covariate_coefs_guess_range = log(c(0.25, 2))
exponentiate_coefs = FALSE
ep_tol = 1e-4
g_intercept
g_perturbation_grid
g_fam
m_fam
m_fam <- poisson() |> augment_family_object()
pi
head(covariate_matrix)
head(g_covariate_coefs)
head(m_offset)
head(g_offset)
alpha
if (!is(m_fam, "family")) m_fam <- m_fam[[1]]
if (!is(g_fam, "family")) g_fam <- g_fam[[1]]
# pull g_fam and m_fam from dat, if available
if ("m_precomp" %in% names(attributes(dat))) {
m_precomp <- attr(dat, "m_precomp"); m_fam <- m_precomp$fam
}
if ("g_precomp" %in% names(attributes(dat))) {
g_precomp <- attr(dat, "g_precomp"); g_fam <- g_precomp$fam
}
# step 0: update the data frame to remove m and p; add the covariates
dat <- dat |> dplyr::mutate(covariate_matrix)
head(dat)
is.null(covariate_matrix)
covariates <- colnames(covariate_matrix)
my_form <- paste0("~ ", paste0(covariates, collapse = "+")) |> as.formula()
my_form
head(dat)
fit <- flexmix::flexmix(g ~ 1, k = 2, data = dat,
model = flexmix::FLXMRglmfix(family = "poisson", offset = g_offset, fixed = my_form))
# step 2: obtain the cluster assignments; ensure 1 (perturbed) is the smaller cluster and 0 (unperturbed) is the larger one
phat <- flexmix::clusters(fit) - 1L
sum(phat)
fit
fit@posterior
fit@cluster |> head()
hist(dat$g)
library(magrittr)
library(glmeiv)
library(simulatr)
print("Running create sim_spec objects")
args <- commandArgs(trailingOnly = TRUE)
overwrite <- TRUE # if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
####################################################################
# Experiment 1 (main text simulation)
# Vary g_pert, fix all other parameters
# Vary distribution: Poisson, NB (known theta), NB (estimated theta)
# One covariate: batch (bernoulli variable)
####################################################################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 50000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson() |> glmeiv::augment_family_object())
})
param_grid$m_fam <- fam_obj
param_grid$run_mrna_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
fixed_params <- list(
g_fam = poisson() |> augment_family_object(),
run_grna_unknown_theta_precomputation = FALSE,
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "thresholding", "unimodal_mixture"))
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1, B_in = 2, parallel = TRUE)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = "thresholding")
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1, B_in = 2, parallel = TRUE, return_data = TRUE)
check$data |> length()
check$data[[21]] |> length()
dat <- check$data[[21]][[1]]
head(Dat)
head(dat)
run_umimodal_mixture_method_simulatr
dat |> head
dat |> head()
g_intercept
g_fam = poisson() |> augment_family_object()
run_grna_unknown_theta_precomputation = FALSE
seed = 4
n = n
B = 500
m_intercept = log(0.01)
m_perturbation = log(0.25)
g_intercept = log(0.005)
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5))
m_covariate_coefs = log(0.9)
g_covariate_coefs = log(1.1)
alpha = 0.95
n_em_rep = 15
save_membership_probs_mult = 1000L
pi = 0.02
m_offset = log(rpois(n = n, lambda = 10000))
g_offset = log(rpois(n = n, lambda = 5000))
pi_guess_range = c(1e-5, 0.03)
m_perturbation_guess_range = log(c(0.1, 1.5))
g_perturbation_guess_range = log(c(0.5, 10))
m_intercept_guess_range = log(c(1e-4, 1e-1))
g_intercept_guess_range = log(c(1e-4, 1e-1))
m_covariate_coefs_guess_range = log(c(0.25, 2))
g_covariate_coefs_guess_range = log(c(0.25, 2))
exponentiate_coefs = FALSE
ep_tol = 1e-4
head(dat)
g_intercept
g_perturbation
g_fam
m_fam
m_fam <- poisson() |> augment_family_object()
pi
head(covariate_matrix)
g_covariate_coefs
m_offset
g_offset
alpha
n_em_rep
pi_guess_range
g_perturbation_guess_range
set.seed(4)
if (!is(m_fam, "family")) m_fam <- m_fam[[1]]
if (!is(g_fam, "family")) g_fam <- g_fam[[1]]
# pull g_fam and m_fam from dat, if available
if ("m_precomp" %in% names(attributes(dat))) {
m_precomp <- attr(dat, "m_precomp"); m_fam <- m_precomp$fam
}
if ("g_precomp" %in% names(attributes(dat))) {
g_precomp <- attr(dat, "g_precomp"); g_fam <- g_precomp$fam
} else {
g_precomp <- run_glmeiv_precomputation(y = g, covariate_matrix = covariate_matrix, offset = g_offset, fam = g_fam)
g_fam <- g_precomp$fam
}
set.seed(4)
if (!is(m_fam, "family")) m_fam <- m_fam[[1]]
if (!is(g_fam, "family")) g_fam <- g_fam[[1]]
# pull g_fam and m_fam from dat, if available
if ("m_precomp" %in% names(attributes(dat))) {
m_precomp <- attr(dat, "m_precomp"); m_fam <- m_precomp$fam
}
if ("g_precomp" %in% names(attributes(dat))) {
g_precomp <- attr(dat, "g_precomp"); g_fam <- g_precomp$fam
} else {
g_precomp <- run_glmeiv_precomputation(y = g, covariate_matrix = covariate_matrix, offset = g_offset, fam = g_fam)
g_fam <- g_precomp$fam
}
# pull g_fam and m_fam from dat, if available
if ("m_precomp" %in% names(attributes(dat))) {
m_precomp <- attr(dat, "m_precomp"); m_fam <- m_precomp$fam
}
# pull g_fam and m_fam from dat, if available
if ("m_precomp" %in% names(attributes(dat))) {
m_precomp <- attr(dat, "m_precomp"); m_fam <- m_precomp$fam
}
if ("g_precomp" %in% names(attributes(dat))) {
g_precomp <- attr(dat, "g_precomp"); g_fam <- g_precomp$fam
} else {
g_precomp <- run_glmeiv_precomputation(y = g, covariate_matrix = covariate_matrix, offset = g_offset, fam = g_fam)
g_fam <- g_precomp$fam
}
g_precomp" %in% names(attributes(dat))
)
g_precomp" %in% names(attributes(dat))
"g_precomp" %in% names(attributes(dat))
run_glmeiv_at_scale_simulatr
set.seed(4)
if (!is(m_fam, "family")) m_fam <- m_fam[[1]]
if (!is(g_fam, "family")) g_fam <- g_fam[[1]]
m <- dat$m
g <- dat$g
# pull g_fam and m_fam from dat, if available
if ("m_precomp" %in% names(attributes(dat))) {
m_precomp <- attr(dat, "m_precomp"); m_fam <- m_precomp$fam
}
if ("g_precomp" %in% names(attributes(dat))) {
g_precomp <- attr(dat, "g_precomp"); g_fam <- g_precomp$fam
} else {
g_precomp <- run_glmeiv_precomputation(y = g, covariate_matrix = covariate_matrix, offset = g_offset, fam = g_fam)
g_fam <- g_precomp$fam
}
time <- system.time({
# step 0: get random starting guesses and fitted grna regression values
guesses <- lapply(list(pi = pi_guess_range,
g_perturbation = g_perturbation_guess_range), function(r) {
stats::runif(n = n_em_rep, min = r[1], max = r[2])})
g_fitted <- g_fam$linkfun(g_precomp$fitted_values)
# step 1: run the reduced glmeiv using the gRNA modality only
reduced_fits <- lapply(seq(1L, n_em_rep), function(i) {
run_reduced_em_algo(m = NULL, g = g, m_fitted = NULL, g_fitted = g_fitted,
m_pert_guess = NULL,
g_pert_guess = guesses$g_perturbation[i],
pi_guess = guesses$pi[i], m_fam = NULL, g_fam = g_fam, use_mrna_modality = FALSE)
})
# step 2: obtain the best run according to log-likelihood
log_liks <- sapply(X = reduced_fits, FUN = function(l) l[["log_lik"]])
best_run <- which.max(log_liks)
best_fit <- reduced_fits[[best_run]]
# step 3: run the full unimodal grna mixture model
fit <- run_full_glmeiv_given_pilot_params(m = NULL, g = g, m_fam = NULL, g_fam = g_fam,
pi_guess = best_fit$pi, m_intercept_guess = NULL,
m_perturbation_guess = NULL, m_covariate_coefs_guess = NULL,
g_intercept_guess = g_precomp$fitted_intercept, g_perturbation_guess = best_fit$g_perturbation,
g_covariate_coefs_guess = g_precomp$covariate_coefs, covariate_matrix = covariate_matrix,
m_offset = m_offset, g_offset = g_offset, use_mrna_modality = FALSE)
# step 4: extract the clusters (phat) and fit the GLM
phat <- as.integer(fit$posterior_perturbation_probs >= 0.5)
# step 5: call the thresholding method simulatr helper
m <- dat$m
out <- thresholding_method_simulatr_helper(phat, m, pi, covariate_matrix, m_fam, m_offset, alpha)
})[["elapsed"]]
thresholding_method_simulatr_helper
install()
library(magrittr)
library(glmeiv)
library(simulatr)
print("Running create sim_spec objects")
args <- commandArgs(trailingOnly = TRUE)
overwrite <- TRUE # if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 50000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson() |> glmeiv::augment_family_object())
})
param_grid$m_fam <- fam_obj
param_grid$run_mrna_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
fixed_params <- list(
g_fam = poisson() |> augment_family_object(),
run_grna_unknown_theta_precomputation = FALSE,
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "thresholding", "unimodal_mixture"))
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1, B_in = 2, parallel = TRUE)
glmeiv::run_umimodal_mixture_method_simulatr
library(magrittr)
library(glmeiv)
library(simulatr)
print("Running create sim_spec objects")
args <- commandArgs(trailingOnly = TRUE)
overwrite <- TRUE # if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 50000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson() |> glmeiv::augment_family_object())
})
param_grid$m_fam <- fam_obj
param_grid$run_mrna_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
fixed_params <- list(
g_fam = poisson() |> augment_family_object(),
run_grna_unknown_theta_precomputation = FALSE,
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "thresholding", "unimodal_mixture"))
