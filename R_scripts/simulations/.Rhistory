check$results$thresholding %>% filter(grid_id == 8, parameter == "m_perturbation")
check$results$glmeiv_fast %>% filter(grid_id == 8, parameter == "m_perturbation")
check$results$glmeiv_fast %>% filter(grid_id == 7, parameter == "m_perturbation")
check$results$glmeiv_fast %>% filter(grid_id == 6, parameter == "m_perturbation")
sim_spec_2
sim_spec_2@parameter_grid
sim_spec_2@run_method_functions
sim_spec_2
check$method_times$thresholding
check$results$thresholding
sim_spec_2
library(magrittr)
library(glmeiv)
library(simulatr)
args
overwrite <- TRUE
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
summarize_results
library(magrittr)
library(glmeiv)
library(simulatr)
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
sim_dir
##############################
# Experiment 0
# Vary g_pert
# Fix distribution to Poisson
# All three methods
# One covariate (batch)
##############################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 15000 # 150000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid)
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
param_grid
fixed_params <- list(
m_fam = poisson() %>% augment_family_object(),
g_fam = poisson() %>% augment_family_object(),
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = m_perturbation,
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
n_processors = 20,
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
run_unknown_theta_precomputation = FALSE,
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
fixed_params
sim_spec_0 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
one_rep_times = one_rep_times,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
one_rep_times
head(param_grid)
head(fixed_params)
sim_spec_0 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
library(magrittr)
library(glmeiv)
library(simulatr)
args <- commandArgs(trailingOnly = TRUE)
overwrite <- if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
sim_dir
##############################
# Experiment 0
# Vary g_pert
# Fix distribution to Poisson
# All three methods
# One covariate (batch)
##############################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 15000 # 150000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid)
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fixed_params <- list(
m_fam = poisson() %>% augment_family_object(),
g_fam = poisson() %>% augment_family_object(),
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = m_perturbation,
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
n_processors = 20,
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
run_unknown_theta_precomputation = FALSE,
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_0 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
create_simulatr_specifier_object
library(magrittr)
library(glmeiv)
library(simulatr)
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
##############################
# Experiment 0
# Vary g_pert
# Fix distribution to Poisson
# All three methods
# One covariate (batch)
##############################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 15000 # 150000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid)
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fixed_params <- list(
m_fam = poisson() %>% augment_family_object(),
g_fam = poisson() %>% augment_family_object(),
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = m_perturbation,
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
n_processors = 20,
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
run_unknown_theta_precomputation = FALSE,
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_0 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
simulatr::check_simulatr_specifier_object
library(magrittr)
library(glmeiv)
library(simulatr)
args <- commandArgs(trailingOnly = TRUE)
overwrite <- if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
sim_dir
##############################
# Experiment 0
# Vary g_pert
# Fix distribution to Poisson
# All three methods
# One covariate (batch)
##############################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 15000 # 150000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid)
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fixed_params <- list(
m_fam = poisson() %>% augment_family_object(),
g_fam = poisson() %>% augment_family_object(),
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = m_perturbation,
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
n_processors = 20,
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
run_unknown_theta_precomputation = FALSE,
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_0 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_0, B_in = 2, parallel = TRUE)
check
check$results$output[1]
output <- check$results$output[[1]]
check$results |> head()
ground_truth <- param_grid$ground_truth[1]
ground_truth
output
output |> print()
output |> print(n = 100)
output |> dplyr::filter(parameter == m_perturbation)
output |> dplyr::filter(parameter == "m_perturbation")
output |> dplyr::filter(parameter == "m_perturbation", value == "estimate")
output |> dplyr::filter(parameter == "m_perturbation", target == "estimate")
output |> dplyr::filter(parameter == "m_perturbation",
target == "estimate") |> dplyr::pull(value)
output |> dplyr::filter(parameter == "m_perturbation",
target == "estimate") |> dplyr::pull("value")
est <- output |> dplyr::filter(parameter == "m_perturbation",
target == "estimate") |> dplyr::pull("value")
# Define functions for evaulation
compute_bias <- function(output, ground_truth) {
est <- output |> dplyr::filter(parameter == "m_perturbation",
target == "estimate") |> dplyr::pull("value")
bias <- est - ground_truth
return(bias)
}
evaluation_functions <- list(bias = compute_bias)
create_simulatr_specifier_object
library(magrittr)
library(glmeiv)
library(simulatr)
args <- commandArgs(trailingOnly = TRUE)
overwrite <- if (is.na(args[1])) TRUE else as.logical(args[1])
save_obj <- function(obj, file_path, overwrite) {
if (!file.exists(file_path)) { # if file does not exist, save
saveRDS(obj, file_path)
} else { # if file does exist, save only if overwrite true
if (overwrite) {
saveRDS(obj, file_path)
}
}
}
sim_dir <- paste0(.get_config_path("LOCAL_GLMEIV_DATA_DIR"), "public/simulations/spec_objects")
####################################################################
# Experiment 1
# Vary g_pert, fix all other parameters
# Vary distribution (Poisson, NB (known theta), NB (estimated theta)
# One covariate: batch (bernoulli variable)
####################################################################
set.seed(4)
theta <- 20
n <- 10000 # n <- 150000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
####################################################################
# Experiment 1
# Vary g_pert, fix all other parameters
# Vary distribution (Poisson, NB (known theta), NB (estimated theta)
# One covariate: batch (bernoulli variable)
####################################################################
set.seed(4)
m_perturbation <- log(0.25)
theta <- 20
n <- 10000 # n <- 150000
g_perturbation_grid <- log(seq(1, 4, 0.5))
param_grid <- expand.grid(g_perturbation = g_perturbation_grid,
fam_str = c("nb_theta_unknown", "nb_theta_known", "poisson"))
param_grid$grid_id <- seq(1, nrow(param_grid))
param_grid$ground_truth <- m_perturbation
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson())
})
param_grid$m_fam <- param_grid$g_fam <- fam_obj
param_grid$run_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
fixed_params <- list(
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
simulatr_spec = sim_spec_1
B_in = 2; parallel = TRUE
B_in
return_data
return_data = FALSE; parallel = TRUE
return_data
parallel
# decide which lapply function to use
if (parallel) {
future::plan(future::multisession())
my_lapply <- function(X, FUN) future.apply::future_lapply(X, FUN, future.seed = NULL)
} else {
my_lapply <- lapply
}
# set basic quantities
n_param_settings <- nrow(simulatr_spec@parameter_grid)
# update B in the fixed parameter list
if (!is.null(B_in)) {
simulatr_spec@fixed_parameters[["B"]] <- B_in
if ("B" %in% colnames(simulatr_spec@parameter_grid)) simulatr_spec@parameter_grid$B <- NULL
}
# set up for data generation across parameter settings; load data generation packages (if necessary)
data_generator <- simulatr_spec@generate_data_function
packs_to_load <- data_generator@packages
if (!(identical(packs_to_load, NA_character_))) invisible(lapply(packs_to_load, function(pack) library(pack, character.only = TRUE)))
# extract the seed
seed <- simulatr_spec@fixed_parameters$seed
cat("Generating data...\n")
# Generate the synthetic data
data_generation_out <- my_lapply(X = seq(1, n_param_settings), FUN = function(row_idx) {
# obtain arguments
ordered_args <- lapply(data_generator@arg_names, function(curr_arg) {
get_param_from_simulatr_spec(simulatr_spec, row_idx, curr_arg)
})
# obtain B; if B_in has been passed, use that instead
B <- get_param_from_simulatr_spec(simulatr_spec, row_idx, "B")
# generate the data, while clocking the time and looking for errors
tryCatch({
invisible(gc(reset = TRUE)) # garbage collect prior to generating data
time <- suppressMessages(system.time(
if (data_generator@loop) {
data_list <- lapply(
1:B,
function(b) {
R.utils::withSeed(do.call(data_generator@f, ordered_args),
seed = seed + b)
}
)
} else {
data_list <- R.utils::withSeed(do.call(data_generator@f, ordered_args), seed = seed)
})[["elapsed"]]/B)
bytes <- get_memory_used()/B
return(list(error = FALSE, warning = FALSE, time = time,
bytes = bytes, data_list = data_list))
# handle errors and warnings
}, error = function(e) {
return(list(error = TRUE, warning = FALSE, ordered_args = ordered_args, msg = e))
}, warning = function(w) {
return(list(error = FALSE, warning = TRUE, ordered_args = ordered_args, msg = w))
})
})
query_funct <- check_funct_helper(data_generation_out, "data generator")
if (query_funct$stop_funct) return(query_funct$ret_val)
load_all("~/research_code/simulatr")
query_funct <- check_funct_helper(data_generation_out, "data generator")
if (query_funct$stop_funct) return(query_funct$ret_val)
query_funct <- check_funct_helper(data_generation_out, "data generator")
query_funct <- check_funct_helper(data_generation_out, "data generator")
cat("Generating data...\n")
seq(1, n_param_settings)
row_idx
row_idx <- 1L
# obtain arguments
ordered_args <- lapply(data_generator@arg_names, function(curr_arg) {
get_param_from_simulatr_spec(simulatr_spec, row_idx, curr_arg)
})
ordered_args |> length()
# obtain B; if B_in has been passed, use that instead
B <- get_param_from_simulatr_spec(simulatr_spec, row_idx, "B")
B
invisible(gc(reset = TRUE)) # garbage collect prior to generating data
data_list <- R.utils::withSeed(do.call(data_generator@f, ordered_args), seed = seed)
data_generator@f
ordered_args[[1]]
ordered_args[[2]]
ordered_args[[1]]
ordered_args[[2]]
ordered_args[[3]]
ordered_args |> length()
ordered_args[[15]]
ordered_args[[4]]
data_list <- R.utils::withSeed(do.call(data_generator@f, ordered_args), seed = seed)
data_list
data_generator@f
fam_obj <- lapply(as.character(param_grid$fam_str), function(str) {
switch(EXPR = str,
"nb_theta_unknown" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"nb_theta_known" = MASS::negative.binomial(theta) |> glmeiv::augment_family_object(),
"poisson" = poisson() |> glmeiv::augment_family_object())
})
param_grid$m_fam <- param_grid$g_fam <- fam_obj
param_grid$run_unknown_theta_precomputation <- as.character(param_grid$fam_str) == "nb_theta_unknown"
fixed_params <- list(
seed = 4,
n = n,
B = 500,
m_intercept = log(0.01),
m_perturbation = log(0.25),
g_intercept = log(0.005),
covariate_matrix = data.frame(batch = rbinom(n = n, size = 1, prob = 0.5)),
m_covariate_coefs = log(0.9),
g_covariate_coefs = log(1.1),
alpha = 0.95,
n_em_rep = 15,
save_membership_probs_mult = 1000L,
pi = 0.02,
m_offset = log(rpois(n = n, lambda = 10000)),
g_offset = log(rpois(n = n, lambda = 5000)),
pi_guess_range = c(1e-5, 0.03),
m_perturbation_guess_range = log(c(0.1, 1.5)),
g_perturbation_guess_range = log(c(0.5, 10)),
m_intercept_guess_range = log(c(1e-4, 1e-1)),
g_intercept_guess_range = log(c(1e-4, 1e-1)),
m_covariate_coefs_guess_range = log(c(0.25, 2)),
g_covariate_coefs_guess_range = log(c(0.25, 2)),
exponentiate_coefs = FALSE,
ep_tol = 1e-4)
sim_spec_1 <- create_simulatr_specifier_object(param_grid = param_grid,
fixed_params = fixed_params,
methods = c("glmeiv_fast", "glmeiv_slow", "thresholding"))
check <- simulatr::check_simulatr_specifier_object(simulatr_spec = sim_spec_1,
B_in = 2, parallel = TRUE)
check
check$metrics
check$metrics
check$metrics |> print(100)
check$metrics |> print(n = 1000)
